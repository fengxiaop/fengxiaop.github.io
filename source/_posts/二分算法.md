---
title: 二分算法
date: 2021-10-15 19:58:33
tags: 二分
cover: https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png
---

###   二分算法

二分算法基本框架

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0,right=nums.length-1,ans=right+1;
        while(left<=right){
        int mid = (left + right)/2;
        if(nums[mid]>=target){
          ans=mid;
          right=mid-1;}
        else 
        left=mid+1;
        }
    return ans;
}
```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。**本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

另外声明一下，计算 mid 时需要技巧防止溢出，即 mid=left+(right-left)/2。本文暂时忽略这个问题。

**一、寻找一个数（基本的二分搜索）**

这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

```java
int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}
```

**1.** 为什么 while 循环的条件中是 <=，而不是 < ？

答：因为初始化 right 的赋值是 nums.length-1，即最后一个元素的索引，而不是 nums.length。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。

我们这个算法中使用的是前者 [left, right] 两端都闭的区间。**这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```
 if(nums[mid] == target)
        return mid;
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

while(left <= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

while(left < right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 while(left < right) 也可以，我们已经知道了出错的原因，就打个补丁好了：

```java
//...
while(left < right) {
    // ...
}
return nums[left] == target ? left : -1;
```

详解解析看 [https://www.cnblogs.com/mxj961116/p/11945444.html]

leetcode_[剑指 Offer II 069. 山峰数组的顶部](https://leetcode-cn.com/problems/B1IidL/)

![山峰数组](https://raw.githubusercontent.com/fengxiaop/gallery/master/image/20211015200546.png)

二分题解

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
    int left = 0 , rigth = arr.length-1,ans = 0;
    while(left<=rigth)
    {
        int mid = (left+rigth)/2;
        if(arr[mid]>arr[mid+1])
        {ans = mid;
        rigth = mid-1;}
        else
        left = mid+1;

    }
    return ans;
    }
}
```

leetcode_35

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

![插入位置](https://raw.githubusercontent.com/fengxiaop/gallery/master/image/20211015200656.png)

题解

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0,right=nums.length-1,ans=right+1;
        while(left<=right){
        int mid = (left + right)/2;
        if(nums[mid]>=target){
          ans=mid;
          right=mid-1;}
        else 
        left=mid+1;
        }
    return ans;
        }
}
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

![](https://github.com/fengxiaop/gallery/blob/master/image/Snipaste_2021-10-15_20-07-58.png?raw=true)



题解

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1,ans = 0;
        while(left <= right)
        {
            int mid=(left+right);
            if(nums[mid] > nums[right]){
                if(target > nums[mid])
                {
                    left = mid+1;
                }
                else if(target < nums[mid])
                {
                    right = mid-1;
                }
                else 
                    ans = mid;
            }
            if(nums[mid] <nums[right]){
                if(target<nums[mid])
                {
                    left=mid+1;
                }
                else if(target > nums[mid])
                {
                    right=mid-1;
                }
                else
                    ans=mid;
            }
    }
    return ans;
}
}
```

